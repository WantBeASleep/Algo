:pensive: Ну, нарешивали нарешивали, а толку то? Вообщем по задумке тут бы классно все струтурировать, как получится хз.  

![FaceOfRepa](/img/me.jpg)  

## List

*Темы без ссылок не нуждаются в просмотре*

* Ya 2.0
    * Линейный поиск
    * Множества
    * [Сортировка подсчетом](#сортировка-подсчетом)
    * Словари
    * [Префиксные суммы](#префиксные-суммы)
    * [Два указателя](#два-указателя)
    * [Бинарный поиск](#бинарный-поиск)
    * [Сортировка событий](#сортировка-событий) *to-do*
    * Деревья
* Ya 3.0
    * [Стеки]



#### Сортировка подсчетом
Пусть дан массив из N элементов таких, что их разброс невелик. Обычная сортировка займет $O(NLogN)$  

Однако, если разбор небольшой проще сосчитать кол-во каждого элемента, а затем восстановить массив  
![NumSort](/img/NumSort.png)

#### Префиксные суммы
Подсчет *чего-либо* на отрезке, быстрый ответ на запрос ~~суммы~~ *операции* на отрезке 

![PreffSum](/img/PreffSum.png)

#### Два указателя
Много задач, формата 2 массива, станцуйте с бубном и т.д. Обычно 2 указателя там очевидны

Далее - метод плавающего окна. Тригер к 2 указателям соблюдение инварианта.

Должно выполнять 2 свойвства

* если отрезок [L,R] хороший, то любой вложенный в него отрезок также хороший
    * если отрезок [L,R] хороший, то любой отрезок, который его содержит также хороший
* Во вторых, вы должны уметь пересчитывать вашу функцию (проверять хороший отрезок или плохой), при увеличении левой или правой границы на единицу вправо.

![2pointers1](/img/2pointers1.png)

![2pointers2](/img/2pointers2.png)

Код всегда максимально похожий  

```
L = 0
for R = 0..n-1
    add(a[R])
    while not good():
        remove(a[L])
        L++
```

Есть еще неплохая темка с очередью на 2 стеках, помогает в задачах, с сложным пересчетом функции. Это нужно, если при удалении/добавлении элемента в наше "окно", самого элемента недостаточно, и нужно учитывать предыдушие, но в таком случае требуется транзитивность, как например хранение максимума на окне, хранения НОД всех чисел и прочее

![2pointersStack](/img/2pointersStackk.png)

#### Бинарный поиск
Сразу не занимаемся херней с поиском на отрезке, там нужно думать, что бы правая и левая граница сошлась, а думать это для дебилов, д - думать, д - дебил  

Главный тригер к бинарке - монотонная функция 2 видов, поиск элемента в массиве, минимакс и т.д.

![BinSearchFunc](/img/BinSearch1.png)

Поиск по таким монотонным функциям места "перегиба" - бинпоиск по ответу

Пусть у нас монотонная, возрастающая функция, тогда при поиске сохраняем инвариант полуинтервала [L, R]:
* L - указывает на "левую" часть функции
* R - правая часть функции
```golang
L := 0 // Левая граница
// крутые математики, сразу могут определить при каком R функция будет true, но д - думать, д - дебил, делаем так
R := 1
for !func(R) {
    R *= 2
}

for R != L + 1 {
    MID := (L + R) / 2
    if good(MID) {
        R = MID
    } else {
        L = MID
    }
}

func good(X int, ...) bool {
    res := // проверяем, удовлетворению условию при X
    return res
}
```

Вещественный бинпоиск - все тоже самое, тот же инвариант, но, условие for-а теперь так просто не задашь, глобально есть 2 варианта
```golang
// 1 eps - точность
eps := 1e-6
for (R - L > eps)

// 2 через итерации
for (i := 0; i != 150; i++)
// 150 итераций - 2^150, вообщем ответ получим с максимальной точностью, у нас на итерации ~60-той, уже будут соседние числа в float64 ~~double~~
```

Минимакс - развал кабины  
Задачи двух видов: $min(max(x_i))$ или $max(min(x_i))$  

Вместо попыток в минимизацию, мы можем просто ограничить функцию $max(x_i)$ сверху, а далее бин поиском подбирать ограничение, это будет та же мемезация за $~O(LogN)$  

Затем мы получим $max(x_i) <= t; \forall x_i <= t$ Обычно это можно проверить за $~O(N)$ 

При $max(min(x_i))$ тоже самое в обратную сторону, ограничиваем снизу, затем решаем задачу $min(x_i) > t$

Максимальное/минимальное среднее - развал кабинx2  
Пускай у нас есть какое-то множество, нам нужно выбрать подмножество, обладающее какими-то свойствами, и в этом подмножестве нужно максимизировать/минимизировать среднее арифметическое элементов.

То бишь 
```math
\frac{\sum_{l}^r a_i}{r - l} \to max
```

в таком случае max/min заменяем на бинарку с ограничением снизу/сверху  

$$\frac{\sum_{l}^r a_i}{r - l} >= x$$  

$$\sum_{l}^r a_i >= x * (r - l)$$  

$$\sum_{l}^r (a_i - x) >= 0$$

подобное ищется префиксными суммами 
```math
  \begin{cases}
    p_r > p_l\\
    r - l >= D 
  \end{cases}
```
В данном случае достаточно хранить индекс минимальной префиксной суммы на отрезке [0, R-L]

**TO-DO** Поиск *K* элемента, разобрать

#### Сортировка событий

**TO-DO**

#### Стеки

Задача на правильную скобочную последовательность, признак стека - *вложенность*

Задача на преобразование в постфиксную запись, опять *некая вложенность*

![преобразование в постфикс](/img/StackPostfix.png)

Задача о поиске ближайшего меньшего справа 

![меньшийсправа](/img/StackLessRight.png)

Тут сложнее. Если нам прилетает число X, то для всех чисел в стеке больше X, чисто X будет ответом, более они не нуждаются в рассмотрении. Также стек будет упорядочен, ведь если $a_i > a_i-1$ в стеке, то $a_i$ вытолкнестся, ответ для него уже найден
test
